
-------------------------------------多线程的创建--------------------------
方式一：
    （1）创建一个继承于Thread类的子类
    （2）重写Thread类的run()
    （3）创建Thread类的子类的对象
    （4）通过此对象调用start()
注意：
    1.strart()作用：启动当前线程、调用当前线程的run()
    2.我们不能通过直接调用run()的方法的方式启动进程
    3.不能让已经start()的线程再执行，需要重新创建一个线程的对象再执行

方式二：
    （1）实现Runnable接口，实现类去实现Runnable中的抽象方法run()
    （2）创建实现类的对象，将此对象作为参数，传递到Thread类的构造器中，
    （3）创建Thread类的对象，通过Thread类的对象调用start()


方式三：
    （1）创建一个实现Callable接口的实现类
    （2）实现call方法，将此线程需要执行的操作声明在call()中
    （3）创建Callable接口实现类的对象
    （4）将此Callable接口实现类的对象作为参数传递到FutureTask构造器中，创建FutureTask的对象
    （5）将FutureTask的对象作为参数传递到Thread类的构造器中，创建Thread对象，并调用start
    （6）获取Callable中call方法的返回值

与使用Runnable相比， Callable功能更强大些 ：
    1.相比run()方法，call()方法可以有返回值
    2.call()方法可以抛出异常
    3.Callable支持泛型的返回值
    4.需要借助FutureTask类，比如获取返回结果


----------------------------------测试Thread中的常用方法--------------------------
    1.start():启动当前线程，调用当前线程的run()
    2.run(): 线程在被调度时执行的操作
    3.currentThread(): 静态方法，返回执行当前代码的线程
    4.getName(): 获取当前线程的名称
    5.setName(String name):设置当前线程名称
    6.yield()：释放当前CPU执行权，线程让步
    暂停当前正在执行的线程，把执行机会让给优先级相同或更高的线程
    若队列中没有同优先级的线程，忽略此方法
    7.join()：在线程a中调用线程b的join(),此时线程a就进入阻塞状态，直到线程b完全执行完以后，线程a才结束阻塞状态
    低优先级的线程也可以获得执行
    8.isAlive()：判断当前线程是否存在
    9.sellp()：让当前线程“睡眠”(阻塞)指定的时间(毫秒数)。
        令当前活动线程在指定时间段内放弃对CPU控制,使其他线程有机会被执行,时间到后重排队。
        抛出InterruptedException异常，需要用try-catch捕获异常
    10.stop()：已过时，当执行此方法时，强制结束当前线程

------------------------------------线程的优先级-------------------------------
    MAX_PRIORITY：10
    MIN_PRIORITY：1
    NORM_PRIORITY：5 -->默认优先级
    getPriority() ：获取线程优先级
    setPriority(int newPriority) ：设置线程的优先级
说明：
    高优先级的线程要抢占低优先级线程的CPU的执行权。
    但是只是从概率上讲，高优先级的线程高概率被执行，并不意外着只有当高优先级的线程执行完以后，低优先级的线程才执行
